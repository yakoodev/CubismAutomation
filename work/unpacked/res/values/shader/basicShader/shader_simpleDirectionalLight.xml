<?xml version="1.0" encoding="UTF-8"?>
<shader language="GLSL">
    <properties>
        <property name="s_texture0" text="Texture" default="red" />
    </properties>
    <blend srcColor="ONE" dstColor="ONE_MINUS_SRC_ALPHA" srcAlpha="ONE" dstAlpha="ONE_MINUS_SRC_ALPHA" />
    <cull mode="BACK" />
    <!--#############################  VERTEX  #############################-->
    <vertex><![CDATA[
#version 150

#if __VERSION__ >= 130
  #define attribute in
  #define varying out
#endif

#ifdef GL_ES
precision mediump float;
precision mediump int;
#endif

// 座標位置の計算用
uniform mat4 worldToCameraMatrix , projectionMatrix, normalMatrix ;
uniform mat4 localToWorldMatrix ;// TEST IMPL

attribute vec4 positions;
attribute vec4 normals;
uniform vec4 lightPosition;
uniform vec4 lightColor ; //ライトカラー
uniform vec4 lightIntensity ; //強度
uniform vec4 baseColor ;

uniform vec3 Kd; //ディフューズ反射率
uniform vec3 Ka; //アンビエント反射率

varying vec4 v_color ; // out vec3 color

vec3 lightIntensityByDiffuse()
{
    vec3 Kd = vec3(1.0);
    vec3 Ka = vec3(0.5);

    //vec3 tnorm = vec3(normalize(normalMatrix * normals));
    vec3 tnorm = vec3(normalize(normalMatrix * vec4(normals.xyz,1.0)));

    vec3 s = normalize(vec3( lightPosition.xyz ));
    float sDotN = max( dot(s,tnorm), 0.0 );

    vec3 diffuse = Ka + (lightIntensity.xyz * (Kd * sDotN));
    diffuse *= lightColor.xyz ;

    return diffuse;
}

void main(void)
{
    v_color = vec4(lightIntensityByDiffuse(), 1.0);
 	gl_Position = projectionMatrix * worldToCameraMatrix * localToWorldMatrix * positions ;
}

]]></vertex>
    <!--############################  FRAGMENT  ############################-->
    <fragment><![CDATA[
#version 150

//#extension GL_EXT_gpu_shader4 : enable

#if __VERSION__ >= 130
  #define varying in
  out vec4 mgl_FragColor;
  #define gl_FragColor mgl_FragColor
#endif

#ifdef GL_ES
precision mediump float;
precision mediump int;
#endif

varying vec4	v_color ;

void main (void)
{
	gl_FragColor = v_color ;
}

]]></fragment>
</shader>

